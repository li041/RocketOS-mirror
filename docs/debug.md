## 内核调试方法详解

本文档结合个人开发日志，详细阐述了内核开发过程中常用的调试方法，并辅以具体的调试案例。

### 1. 调试环境与工具

- **QEMU模拟器**：作为主要的内核运行和测试平台。启动RISC-V内核的QEMU命令如下，包括内存分配、图形界面设置、CPU数量以及虚拟块设备的加载等详细参数。
    - **示例**：        
```
        qemu-system-riscv64 -machine virt \
            -kernel target/riscv64gc-unknown-none-elf/release/os.bin \
            -m 128M -nographic \
            -smp 2 \
            -bios ../bootloader/opensbi-qemu.bin \
            -drive file=../fs-img-src/fs.img,if=none,format=raw,id=x0 \
            -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 \
            -device virtio-net-device,netdev=net -netdev user,id=net
```
- **调试挑战**：在LoongArch架构下，曾遇到“`qemu-system-loongarch`跑起来了，能够给`ctrl+a+x`退出，但是没有输出到命令行”的问题，这需要进一步排查QEMU配置或内核输出机制。
	- 最后发现是工具链存在问题， 从比赛测试docker环境获得qemu-system-loongarch就可以了
- **GDB调试器**：用于进行符号级调试，例如“在目前情况在gdb调试中查看tid”。这意味着可以利用GDB在QEMU中设置断点、检查寄存器、查看内存等。
- **测试套件**：通过运行各种用户态测试程序和基准测试工具来发现内核问题，验证功能正确性和性能。
    - `LTP (Linux Test Project)`
### 2. 常见调试场景与具体案例
- **内核栈与TrapContext调试**：
    - **问题**：内核栈分配、`TrapContext`的保存与恢复、上下文切换时寄存器状态异常。例如，“matrix发生page fault - 原因是trap中使用t0, 一定要在保存后和恢复前用这些寄存器，否则覆盖了”。此外，“在user_shell fork的时候down掉 - 内核栈的分配问题”也指向内核栈处理的复杂性。
    - **调试方法**：
        - 仔细检查`TrapContext`的裸指针读写是否正确，以及函数调用对内核栈的影响是否导致`TrapContext`未能按预期读出。
        - 确保RISC-V中栈指针16字节对齐的要求，并通过`#[repr(c)]`和`#[repr(align(16))]`限制内核栈中结构体的对齐方式。
        - 在`__trap_from_user`到`trap_return`的流程中，单步调试检查栈位置是否发生变化。
        - `#debug`条目提示“好像是因为tp的问题，user会改变tp”，这表明在用户态和内核态切换时，`tp`寄存器的值可能被意外修改，需要确保其正确保存和恢复。
            
- **内存管理调试**：
    - **问题**：频繁出现缺页中断（Page Fault）、内存映射错误、系统调用相关的内存分配问题。
    - **调试案例**：
        - “动态链接库的路径好像有问题... “：0x300001f000应该是在内核页表中才对，是interprter的区域 - `sys_mprotect`导致原来有的映射没了”。这表明`sys_mprotect`可能错误地修改了已有的内存区域，导致访问冲突。
        - “#debug 最开始len是132f50, prot: 0x5 - 没有实现instruct page fault - Ok - 跳转到0x0x2000030e92死在0x2000030eb2”。此问题涉及指令缺页中断处理不完善和代码跳转异常，可能需要检查页表权限和指令流。
        - LoongArch架构下“`sys_brk`懒分配在恢复时没找到 - `map_area`中出现有重叠的area”，揭示了`sys_brk`在处理内存区域重叠时的潜在错误。
        - “`sys_brk`有bug” 和 “`sys_munmap`有问题” 等直接指出特定内存管理系统调用的缺陷。
        - “`Unixbench`死了 - 应该是`Unixbench ARITHOH test(lps)`是出现instruction page fault - 可能是`sigalarm`信号处理例程导致的，覆盖a0”。这类问题复杂，可能涉及信号处理与内存访问的交互。
            
- **系统调用调试**：
    - **问题**：许多日志条目直接指出特定系统调用的功能性缺陷。
    - **调试案例**：
        - “破案了，`sys_exec`实现有问题”——这是一个明确的系统调用bug。
        - “#检查 `sys_waitpid`写的时候对于用户给的地址还要做检查，`sys_exec`也是，`sys_exit`也是，`sys_read`也是，`sys_getcwd`也是”。这强调了对用户态传入地址进行严格检查的重要性，以防止安全漏洞或内核崩溃。
        - “`mkdir`初步测试 - `inode_num`的分配有问题... `sys_openat`, `sys_mkdirat`对于`pre-2023`测例过了”。表明文件系统相关的系统调用可能存在资源分配问题。
        - “卡死在`writev`”，这是一个典型的I/O系统调用阻塞问题。
        - “Unsupported syscall id: `29, 94, 96, 174`”，这需要内核支持更多的系统调用以运行更复杂的应用。
- **文件系统调试**：
    - **问题**：涉及FAT32/Ext4文件系统操作的各种错误，如目录项读取、空洞文件处理、inode管理等。
    - **调试案例**：
        - “`FAT32DirEntry`的`read_dentry`方法中没有进行错误处理...没有读出文件，是`read_dentry`的问题，返回的数据是全0”。这意味着目录项读取逻辑存在bug。
        - “空洞没有真的写回磁盘，在page sync时如果是稀疏文件，此时inode已经被释放了，没法写回”。此问题涉及到稀疏文件的页同步和inode生命周期管理。
        - “`busybox ls`循环不出来，可能是没有正确判断目录结束”。一个常见的文件系统逻辑错误，导致目录遍历无限循环。
        - “`unlink`可能需要进一步调试，目前测试过了”，表示虽然通过了初步测试，但`unlink`的资源释放等深层逻辑可能仍需细致检查。
            
- **并发与同步调试**
    - **问题**：线程同步机制（如`futex`）和进程间通信（如管道）可能导致死锁或忙等待。
    - **调试案例**：
        - “在`futex_wait`中busyloop了 - `futex`改为阻塞”。一个典型的同步问题，通过将忙等待改为阻塞等待来解决。
        - “`busybox echo hello | busybox uniq` - 死锁了”。明确指出管道使用导致的死锁。
        - “管道有问题”，以及“`pipe`有问题，或者`cow`, `lazy allocation`有问题”，表明管道的实现、写时复制或懒分配机制可能存在协同问题。
- **性能调试**：
    - **问题**：基准测试工具（如`lmbench`）运行缓慢。
    - **调试案例**：
        - “`lmbench`很慢，时间花在`clock_gettime`和`getrusage`上”。这提示性能瓶颈可能在时间获取或资源使用统计的系统调用中。
### 3. 通用调试实践
- **系统性检查**：日志中大量使用`#检查`、`#todo`、`#重要`等标签，在代码中预留了大量的检查点，并对未完成或存疑的功能进行了标记，这是一种系统性的调试和质量保证方法。
- **问题归因与解决**：通过分析和测试最终定位并解决了问题。调试过程中问题归因非常重要，往往只有探明原因才能够有解决思路，具体一定要定位到问题逻辑的代码块。
- **大模型在内核开发和调试中的作用**： 
	- 生成测试用例： “ 大模型可以根据内核模块的输入规范和行为模式，生成更智能、更具针对性的模糊测试用例，增加发现潜在bug的概率。
	- 帮助理解Linxu代码：Linux内核代码庞大且复杂，包含大量低级操作、并发机制和硬件交互。大模型可以帮助开发者快速理解特定函数、模块或子系统的功能、工作原理和设计意图
- **代码重构与架构调整**：当现有框架无法解决某些复杂问题时，日志中也提到了重构（如“重构mm”）和架构调整（如“#todo #架构 可能需要重新架构”）作为解决问题的途径，这本身也是一种高级的解决bug的策略。不过会花费大量的时间， 最好还是在早期广泛调研，完善设计
- **交叉验证**：在LoongArch移植过程中，参考其他优秀项目（如[educg-net-26011-2376549 / OSKernel2024-NPUcore-IMPACT-312 · GitLab](https://gitlab.eduxiji.net/educg-group-26011-2376549/T202410699992496-312)）的代码和文档（如`rCoreloongArch-tutorial`）也是一种有效的调试和学习方法。