#import "../components/cover.typ": *
#import "../components/figure.typ": *

= 硬件平台适配

VisionFive2开发板是StarFive公司推出的RISC-V架构单板计算机，采用开源的RISC-V指令集架构，具有良好的开放性和可扩展性。该开发板主要面向桌面应用、AI开发和视觉处理等场景，支持多种主流操作系统，为RISC-V生态系统的发展提供了重要的硬件平台支撑。

龙芯2K1000开发板则基于中国自主研发的龙芯处理器架构，采用MIPS64指令集，是完全自主可控的国产化解决方案。该开发板主要定位于工业控制、嵌入式应用和物联网等领域，具有低功耗、高稳定性的特点，已在轨道交通、电力系统等关键基础设施中得到广泛应用，代表了国产处理器在实际应用中的成熟度和可靠性。

目前，RocketOS 已经成功实现了VisionFive2开发板与龙芯2K1000开发板的支持，并不断优化和完善对这两款开发板的适配。

== VisionFive2 开发板适配

=== 启动适配

  由于VisionFive 2开发板采用了与标准QEMU环境不同的内存布局设计，其系统入口点位于0x40000000地址，该地址区域不仅包含了内核代码的加载位置，还涵盖了关键的MMIO寄存器映射区域。这种硬件设计要求RocketOS在启动过程中必须对MMIO寄存器进行专门的地址空间处理，以确保内核能够正确访问和控制各种硬件外设。

  RocketOS在VisionFive2平台上的实际运行地址为0xffffffc040200000，这是一个位于内核高地址空间的虚拟地址，与QEMU环境中的标准启动基址存在显著差异。为了实现从U-Boot引导程序到内核的平滑过渡，系统必须建立完整的地址映射机制，确保从物理地址模式到虚拟地址模式的转换过程中不会出现访问中断或地址失效的问题。这种地址空间的转换不仅涉及内核代码本身的重定位，还需要保证MMIO寄存器访问的连续性和有效性。

  启动页表中特别设置的0x40000000到0x40000000的恒等映射以及0xffff_fc00_40000000到0x40000000的高地址映射，共同构成了这一转换机制的核心。恒等映射确保了在虚拟内存系统启用的初始阶段，当前正在执行的代码和MMIO寄存器仍能通过原始的物理地址正常访问，避免了地址空间切换过程中的执行异常。同时，高地址映射建立了标准的内核虚拟地址空间布局，使得内核能够在统一的虚拟地址空间中管理代码、数据和硬件资源。通过这种双重映射策略，RocketOS能够在保持与VisionFive2硬件特性完全兼容的同时，实现向标准内核虚拟内存管理模式的平滑过渡，为后续的系统初始化和设备驱动程序的正常运行奠定了坚实的基础。
== 龙芯2K1000 开发板适配

=== 启动适配

  当系统从U-Boot引导程序获得控制权时，引导环境已经预先配置了两个关键的内存映射段供后续的内核初始化使用。其中第一个段位于虚拟地址0x9000，该段被配置为一致可缓存模式，通过DMW1（Direct Memory Window 1）机制实现直接内存映射，这种配置允许处理器对该区域的数据进行缓存操作，从而提供更高的访问性能；第二个预映射段则位于虚拟地址0x8000，采用无缓存的直接内存访问模式，通过DMW0（Direct Memory Window 0）机制进行映射。这种无缓存配置确保了对该内存区域的所有访问都直接作用于物理内存，避免了缓存一致性问题。

  MMIO（Memory-Mapped I/O）寄存器的访问必须通过无缓存的DMW0直接内存窗口进行，这是由硬件寄存器访问的本质特性所决定的。当处理器需要与外设进行通信时，这些外设的控制寄存器、状态寄存器和数据寄存器都被映射到特定的物理内存地址空间中，形成了内存映射I/O的访问模式。由于这些寄存器的值可能会因为外设的状态变化而实时更新，或者写入操作会立即触发硬件动作，因此任何缓存机制都可能导致严重的一致性问题。

  基于上述特性，RocketOS 在启动龙芯2K1000 开发板过程中会首先配置这两个内存映射段，以确保内核能够正确访问硬件寄存器和其他关键资源。我们的内核启动代码会在引导过程中执行如下算法：

  #algorithm-figure(
    ```rs
    Input: boot_environment
    Output: kernel_memory_layout
    1:    t0 ← PC + 0                    # 获取当前程序计数器
    2:    t0 ← (t0 >> 48) << 48          # 提取物理地址高位
    3:    t0 ← t0 + 0x11                 # 添加内存属性标识
    4:    CSR_0x181 ← t0                 # 配置DMW1窗口
    5:    t0 ← 0
    6:    t1 ← t0 + 0x11                 # 构造0段配置参数
    7:    CSR_0x180 ← t1                 # 配置DMW0为无缓存模式
    8:    t0 ← PC + 0                    # 重新获取当前地址
    9:    t0 ← (t0 << 16) >> 16          # 保留地址低位
    10:   jump t0 + 0x10                 # 跳转到0段映射地址
    11:   t2 ← 0
    12:   t2 ← t2 + 0x11
    13:   CSR_0x181 ← t2                 # 重置DMW1配置
    14:   CSR_0x180 ← t1                 # 恢复UART功能
    ```,
    caption: [内存映射窗口切换算法],
    label-name: "memory-mapping-switch",
  )

  #h(2em)该实现采用先配置映射窗口再执行跳转的策略，主要是为了避免程序执行过程中出现地址空间访问异常。具体而言，如果当前程序计数器所指向的代码段位于DMW0映射的地址区间内而非DMW1区间，那么直接覆盖DMW0寄存器的配置将导致当前执行地址立即失效，从而引发非法内存访问异常。

  为确保地址空间切换过程的安全性，代码首先将当前代码段的映射信息保存到DMW1寄存器中，建立一个临时的有效地址映射。这一预防性措施保证了在随后对DMW0进行重新配置时，程序计数器始终指向一个有效的内存地址空间。只有在确保至少存在一个有效的直接内存窗口映射当前执行位置后，系统才会执行地址空间的跳转操作。

=== 访存对齐要求

  当前开源LLVM工具链中的LoongArch后端存在代码生成限制，无法产生严格遵循内存对齐要求的目标代码。这一技术局限性直接影响了基于LLVM后端进行代码生成的Rust编译器，导致其无法为2K1000开发板生成可正常执行的二进制代码。由于该硬件平台对内存访问的对齐性有严格要求，编译器生成的不对齐内存访问指令将触发硬件异常，因此需要在系统层面实现专门的不对齐异常处理机制来确保程序的正常运行。

  为了解决这一兼容性问题，系统在异常处理框架中集成了专门的不对齐访存异常处理机制。当处理器执行到不对齐的内存访问指令时，硬件会产生AddressNotAligned异常，该异常会被系统的异常处理机制捕获。异常处理程序__trap_from_kernel会识别异常类型并将控制权转移给专用的kernel_trap_handler函数，该函数负责分析触发异常的具体指令类型和访存模式。
  
  kernel_trap_handler通过指令解析确定异常指令是store操作还是load操作，并获取相应的源寄存器、目标寄存器以及内存地址等关键信息。随后，处理程序会执行指令的模拟执行过程，将原本的单个不对齐访存操作分解为多个字节级别的对齐访存操作，通过软件方式完成数据的读取或写入。这种模拟执行机制确保了即使在硬件不支持不对齐访存的情况下，由编译器生成的不对齐访存指令仍能正确完成其预期功能，从而维持程序执行的正确性和连续性，有效弥补了编译器后端和目标硬件平台之间的兼容性差距

=== 编译器特性配置优化

  为了确保生成的代码能够在2K1000开发板上稳定运行，项目采用了特定的Rust编译器特性配置参数"-Ctarget-feature=-ual,-lsx,-lasx,-lvz"来精确控制代码生成行为。这一配置策略通过选择性禁用某些LoongArch架构的高级特性，解决了编译器后端与目标硬件平台之间的兼容性问题。

  通过禁用ual（Unaligned Access Load）特性，编译器被强制要求生成严格遵循内存对齐规范的访存指令，避免了在不支持不对齐访存的硬件平台上触发异常的风险。禁用lsx和lasx这两个SIMD扩展指令集确保了编译器不会生成依赖128位或256位向量处理单元的指令。通过禁用lvz虚拟化扩展特性，系统避免了对硬件虚拟化功能的依赖，确保生成的代码能够在不支持虚拟化扩展的简化硬件配置上正常执行

  #pagebreak()