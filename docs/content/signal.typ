#import "../components/cover.typ": *
#import "../components/figure.typ": *

= 信号处理模块
  信号是操作系统向进程传递事件通知的一种机制，主要用来通知进程某个特定事件的发生，或者是让进程执行某个特定的处理函数。

== 信号结构

  Sig结构是信号在内核中的基本承载体，设计简洁高效，专门用于内核内部的信号管理和处理。它包含了信号识别、分发和处理过程中的核心信息，去除了冗余字段，确保在信号处理的关键路径上保持最佳性能。

  SigInfo结构则为信号传递提供了更丰富的信息描述。在RocketOS中，SigInfo包含了信号处理中最常用的关键字段：signo标识具体信号类型，code提供信号产生的原因和上下文，fields根据不同信号类型承载相应的附加数据。这种精简设计既满足了大部分信号处理需求，又避免了结构过于庞大影响系统性能。

  #code-figure(
    ```rs
    pub struct SigInfo {
        pub signo: i32,      // 信号值
        pub code: i32,       // 信号产生原因
        pub fields: SiField, // 额外信息
    }
    ```,
    caption: [SigInfo结构],
    label-name: "SigInfo结构"
  )

  #h(2em)当涉及用户态和内核态之间的信号信息传递时，RocketOS采用LinuxSigInfo结构作为标准化接口。LinuxSigInfo严格遵循POSIX标准规范，包含标准要求的所有字段和数据布局，确保与现有Linux应用程序的完全兼容。这种设计不仅体现在数据结构字段对应上，还包括内存布局、字节对齐以及各种信号类型特定信息的组织方式

  通过内核内部使用精简Sig和SigInfo结构，而在系统调用接口使用标准LinuxSigInfo结构的双重设计，RocketOS实现了内核效率与标准兼容性的平衡，既保证了内核高效运行，又确保了应用程序的无缝迁移和正确执行。

== 信号发送

  对于线程级信号处理，系统采用精确定向策略，借助任务管理器结构获取指定任务结构，直接操作目标任务的信号待处理队列，将新接收的信号信息按序插入队列结构中。这一机制通过队列缓冲确保了信号的可靠传递，即便目标线程当前处于繁忙执行状态，信号也不会因为时序冲突而丢失，为异步通信提供了坚实的可靠性保障。

  进程级信号的处理逻辑则更为复杂，因为此类信号具有广播特性，需要同时影响整个线程组内的所有线程实体。系统通过遍历线程组中的每个线程，并对每个线程执行与线程级信号完全一致的入队操作序列，从而确保进程级事件能够均匀传播至所有相关执行单元。

  由于信号具有异步中断特性，原本处于阻塞等待状态的任务需要具备被强制唤醒的能力。因此，在信号发送流程中，系统会主动检测目标任务的当前阻塞状态。当检测到任务正处于阻塞等待中，且接收到的信号类型具有阻塞中断权限时，系统会立即执行解除阻塞操作：将任务从相应的阻塞等待队列中移除，同时在任务状态字段中设置"信号中断唤醒"标记，并将该任务重新插入就绪队列等待调度。这种抢占式唤醒机制保障了信号驱动事件的实时性，确保被阻塞任务能够突破原有等待条件的束缚，及时响应关键系统事件或用户请求。

  #figure(
    image("img/信号发送流程图.drawio.png", width: 41%),
    caption: [信号发送流程图]
  ) <send_signal_chart>

== 信号处理流程
  === 基本信号处理流程
  信号的处理流程是操作系统中一个精密的异步事件处理机制。当系统事件发生时，内核首先在目标进程的进程控制块中设置相应的信号标志位，将信号标记为待处理状态。信号不会立即处理，而是等待特定时机，主要是进程从内核态返回用户态时、被唤醒时或系统调用返回时。

  内核检查待处理信号时，会先查看进程的信号屏蔽字，确定哪些信号被阻塞。对于未阻塞的信号，根据处理方式分别执行：默认处理直接执行系统预定义操作；忽略信号则清除待处理标志；自定义处理最为复杂。

  执行自定义信号处理时，内核先保存进程当前的执行上下文，在用户栈上构造特殊栈帧，修改程序计数器指向处理函数，并传递信号参数。进程在特殊环境中执行处理函数，期间通常会自动阻塞同类型信号防止重入。处理函数应保持简单快速，避免调用不安全函数。

  函数返回后，控制权转移到内核预设的返回代码，触发系统调用通知处理完成。内核随后执行清理工作，恢复保存的执行上下文、清理栈帧、恢复信号屏蔽字，最终将进程执行流程恢复到信号发生前的状态，确保进程继续正常执行。

  #figure(
    image("img/信号处理流程.drawio.png", width: 63%),
    caption: [信号处理流程图]
  ) <custom_signal_chart>

=== 对SA_RESTART的特别处理
  SA_RESTART是Linux信号处理架构中的关键标志位，专门用于解决信号中断与系统调用执行之间的协调问题，保障系统调用的执行连续性和操作可靠性。

  在传统Linux实现中，SA_RESTART标志位采用"先重置后撤销"的处理策略，虽然这种方式能够确保信号处理逻辑的正确性，但会产生不必要的状态保存开销，降低了系统调用的执行效率。而在RocketOS中，我们采用了更为精细化的优化策略：通过多重条件判断机制来决定是否执行重置操作，避免了盲目的状态保存。这一判断机制基于四个关键条件进行综合评估，只有在确实需要重置的情况下才执行相应操作，从而显著减少了不必要的系统开销，提升了信号处理的整体性能。
   #pad(left: 3em)[
  + 需要重启的系统调用是否可以重启
  + 信号处理函数是否存在SA_RESTART标志位
  + 信号处理函数是否被被用户注册
  + 任务是否被信号中断阻塞
   ]

   #code-figure(
    ```rs
      if task.can_restart()
          && action.flags.contains(SigActionFlag::SA_RESTART)
          && task.is_interrupted() 
          && action.sa_handler != SIG_DFL 
          && action.sa_handler != SIG_IGN
      {
          // 回到用户调用ecall的指令
          trap_cx.set_sepc(trap_cx.sepc - 4);
          trap_cx.restore_a0(); // 从last_a0中恢复a0
      }
    ```,
    caption: [SA_RESTART判断条件],
    label-name: "SA_RESTART判断条件",
  )

=== sigframe结构设计
  在用户态进程的信号处理机制中，SA_SIGINFO标志位扮演着关键的角色，它决定了内核在信号处理过程中采用何种策略来构造和管理信号上下文信息。这个标志位的存在与否直接影响着信号处理函数的调用方式、参数传递机制以及上下文保存恢复的具体实现。当用户态进程通过sigaction系统调用注册自定义信号处理函数时，如果在sa_flags字段中设置了SA_SIGINFO标志位，这向内核表明该信号处理函数需要接收详细的信号信息。内核会根据这个标志位的存在来选择合适的信号帧结构体类型，确保为信号处理提供正确的上下文环境和参数传递机制。

  对于未设置SA_SIGINFO标志位的情况，内核采用传统的信号处理方式。在这种模式下，内核会直接调用用户态的信号处理函数，仅将信号编号作为单一参数传递给处理函数。这种简化的处理方式对应着较为精简的上下文保存需求，因此内核选择构造常规的SigFrame结构体来满足这一需求。SigFrame结构体设计简洁明了，包含了一个FrameFlags类型的flag字段用于标识结构体类型，以及一个SigContext结构体用于保存处理器的执行上下文信息。

  #code-figure(
    ```rs
      pub struct SigFrame {
          pub flag: FrameFlags,       // 标志位
          pub sigcontext: SigContext, // 上下文信息
      }
      pub struct SigContext {
          pub sepc: usize,
          pub x: [usize; 32],
          pub last_a0: usize,
          pub kernel_tp: usize,
          pub mask: SigSet, // 记录原先的mask
      }
    ```,
    caption: [SigContext结构],
    label-name: "SigContext结构",
  )

  #h(2em)当用户信号处理程序注册时设置了SA_SIGINFO标志位，情况变得更加复杂和功能丰富。在这种情况下，信号处理函数不仅需要接收信号编号，还需要获得包含详细信号信息的siginfo结构体以及完整的用户上下文信息。为了满足这些额外的需求，内核必须构造更为完整和复杂的SigRTFrame结构体。SigRTFrame结构体代表了信号处理机制的高级形态，它不仅包含了用于标识结构类型的flag字段，还整合了UContext结构体来提供完整的用户上下文信息，以及LinuxSigInfo结构体来传递详细的信号相关信息。这种设计使得信号处理函数能够获得更丰富的上下文信息，从而实现更精细化的信号处理逻辑。

  #figure(
    image("img/sigframe结构图.drawio.png", width: 50%),
    caption: [SigRTFrame结构图]
  ) <SigRTFrame>

  #h(2em)在用户信号处理流程结束后，会自动通过预先设置的跳板平台来调用sigreturn返回内核态，在sigreturn中通过在信号处理完成后检查sigframe中的flag字段，内核能够准确识别当前使用的结构体类型，从而选择相应的恢复策略来提取正确的上下文信息。这种设计不仅保证了不同信号处理模式下的功能正确性，还优化了系统资源的使用效率，避免了在简单信号处理场景中构造过于复杂的上下文结构。

  #figure(
    image("img/用户信号流程图.drawio.png", width: 70%),
    caption: [信号处理流程图]
  ) <custom_signal_chart>

#pagebreak()