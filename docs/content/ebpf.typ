= eBPF模块

eBPF（Extended Berkeley Packet Filter）是一种运行在内核态的可编程执行环境，能够在不修改内核源码的情况下扩展内核功能。在现代操作系统中，eBPF 被广泛应用于网络数据包过滤、性能分析、安全监控以及系统调用拦截等场景。在本内核中，eBPF 框架的引入旨在为开发者提供高效、可扩展且安全的内核态执行机制。相比传统的内核模块开发，eBPF 程序具备即时加载、沙箱执行与细粒度权限控制的优势。

RocketOS实现了一个简化版 eBPF 框架(如#[@fig:eBPF框架]所示)，支持从用户态加载程序、管理内核态数据结构（BPF Map）、绑定内核事件（BPF Link），并能够通过 BTF（BPF Type Format）提供类型信息支持。该框架在保持功能可用的前提下，尽可能贴近 Linux 的 bpf() 系统调用语义，以便后续实现部分兼容性。
#figure(image("img/ebpf.png", width: 80%), caption: [eBPF框架], supplement: [图])<eBPF框架>

== 系统调用接口
本内核的 eBPF 子系统通过一个统一的系统调用 bpf() 暴露给用户态。该系统调用的行为由用户态传入的 子命令（command） 以及 属性结构（bpf_attr） 决定。
bpf_attr 是一个多用途的联合体，其具体解释依赖于子命令类型。本实现部分参考了 Linux 内核 kernel/bpf/syscall.c 的语义，但进行了适配与裁剪，以适合RocketOS的运行环境与内存管理模型。以下介绍已实现的主要子命令：
#pad(left: 2em)[
- `bpf_prog_load`: 从用户态加载一段 eBPF 指令序列到内核中，并创建一个可执行的 BpfProg 对象。该对象会在文件描述符表中注册，返回给用户态的 FD 可用于后续的程序绑定与执行。
- `bpf_map_create`: 在内核中创建一个 BPF Map 对象，用于存储键值对数据。
- `bpf_map_update_elem`: 向指定的 BPF Map 中插入或更新一个键值对。`bpf_map_lookup_elem`从指定的 BPF Map 中查找一个键对应的值，并将结果返回给用户态。
- `bpf_link_create`: 将一个已加载的 eBPF 程序绑定到一个内核事件（如网络数据包接收、系统调用等）。绑定后，当事件发生时，eBPF 程序会被自动触发执行。
- `bpf_iter_create`: 创建一个迭代器，用于遍历内核中的某些数据结构（如进程列表、文件系统等）。迭代器本质上是一个特殊的 BPF Map，允许用户态通过标准接口访问内核数据。
]

== eBPF虚拟机
eBPF 是一个 RISC 寄存器机，共有 11 个 64 位寄存器，一个程序计数器和一个 512 字节固定大小的堆栈。其中，R10寄存器作为只读帧指针，用于安全访问栈空间。程序计数器控制指令顺序执行，指令编码遵循固定格式以保证解析效率。

== 工作流
eBPF 程序的执行过程高度依赖于内核事件的触发机制。通过 BPF Link 绑定后，内核在相应事件（如网络数据包接收、系统调用入口等）发生时，会自动调用 eBPF 虚拟机或 JIT 代码执行程序逻辑。程序通过预定义的寄存器和栈访问事件上下文数据，结合 BPF Map 访问共享数据，实现对内核行为的实时监控和动态控制。为了保障内核稳定性，RocketOS 对 eBPF 程序的执行时间设有限制，并限制程序对内核辅助函数（helper functions）的调用范围，防止滥用或恶意行为。类型安全方面，利用 BTF 提供的类型元信息，内核能够动态解析和校验 eBPF 程序对复杂数据结构的访问，极大提升了程序的安全性和健壮性。

== 总结
RocketOS 通过引入 eBPF 框架，实现了一种高效、灵活且安全的内核扩展机制，为开发者提供了强大的工具以动态适应复杂多变的系统需求，彰显了现代操作系统内核设计的前沿趋势。尽管 RocketOS 的 eBPF 框架尚处于简化阶段，尚未涵盖所有 Linux 内核中支持的程序类型、映射类型及辅助函数，但其设计和实现充分体现了 eBPF 技术的核心理念，并为未来的功能扩展和跨平台兼容奠定了坚实基础。未来计划包括丰富支持的 Map 类型（如 LRU 哈希、per-CPU 数组）、完善 verifier 逻辑以加强安全性、拓展对更多硬件架构的 JIT 支持，以及加深 eBPF 与内核网络栈、文件系统和调度子系统的集成。


#pagebreak()